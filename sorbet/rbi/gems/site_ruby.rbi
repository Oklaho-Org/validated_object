# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: false
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/site_ruby/all/site_ruby.rbi
#
# site_ruby-2.7.0

module Bundler
  def URI(uri); end
  def self.URI(uri); end
  def self.require_thor_actions; end
end
module Bundler::SharedHelpers
  def bundler_ruby_lib; end
  def chdir(dir, &blk); end
  def clean_load_path; end
  def const_get_safely(constant_name, namespace); end
  def default_bundle_dir; end
  def default_gemfile; end
  def default_lockfile; end
  def digest(name); end
  def ensure_same_dependencies(spec, old_deps, new_deps); end
  def filesystem_access(path, action = nil, &block); end
  def find_directory(*names); end
  def find_file(*names); end
  def find_gemfile; end
  def gemfile_names; end
  def in_bundle?; end
  def major_deprecation(major_version, message, print_caller_location: nil); end
  def md5_available?; end
  def pretty_dependency(dep, print_source = nil); end
  def print_major_deprecations!; end
  def prints_major_deprecations?; end
  def pwd; end
  def resolve_path(path); end
  def root; end
  def search_up(*names); end
  def set_bundle_environment; end
  def set_bundle_variables; end
  def set_env(key, value); end
  def set_path; end
  def set_rubylib; end
  def set_rubyopt; end
  def trap(signal, override = nil, &block); end
  def validate_bundle_path; end
  def with_clean_git_env(&block); end
  def write_to_gemfile(gemfile_path, contents); end
  extend Bundler::SharedHelpers
end
class Gem::Ext::Builder
  def build_args; end
  def build_args=(arg0); end
  def build_error(output, backtrace = nil); end
  def build_extension(extension, dest_path); end
  def build_extensions; end
  def builder_for(extension); end
  def initialize(spec, build_args = nil); end
  def self.class_name; end
  def self.make(dest_path, results); end
  def self.run(command, results, command_name = nil); end
  def write_gem_make_out(output); end
  include Gem::UserInteraction
end
module Bundler::UI
end
class Bundler::Thor
  def help(command = nil, subcommand = nil); end
  def self.banner(command, namespace = nil, subcommand = nil); end
  def self.baseclass; end
  def self.check_unknown_options!(options = nil); end
  def self.check_unknown_options?(config); end
  def self.command_help(shell, command_name); end
  def self.create_command(meth); end
  def self.create_task(meth); end
  def self.default_command(meth = nil); end
  def self.default_task(meth = nil); end
  def self.deprecation_warning(message); end
  def self.desc(usage, description, options = nil); end
  def self.disable_required_check!(*command_names); end
  def self.disable_required_check; end
  def self.disable_required_check?(command); end
  def self.dispatch(meth, given_args, given_opts, config); end
  def self.dynamic_command_class; end
  def self.find_command_possibilities(meth); end
  def self.find_task_possibilities(meth); end
  def self.help(shell, subcommand = nil); end
  def self.initialize_added; end
  def self.long_desc(long_description, options = nil); end
  def self.map(mappings = nil, **kw); end
  def self.method_option(name, options = nil); end
  def self.method_options(options = nil); end
  def self.normalize_command_name(meth); end
  def self.normalize_task_name(meth); end
  def self.option(name, options = nil); end
  def self.options(options = nil); end
  def self.package_name(name, _ = nil); end
  def self.printable_commands(all = nil, subcommand = nil); end
  def self.printable_tasks(all = nil, subcommand = nil); end
  def self.register(klass, subcommand_name, usage, description, options = nil); end
  def self.retrieve_command_name(args); end
  def self.retrieve_task_name(args); end
  def self.stop_on_unknown_option!(*command_names); end
  def self.stop_on_unknown_option; end
  def self.stop_on_unknown_option?(command); end
  def self.subcommand(subcommand, subcommand_class); end
  def self.subcommand_classes; end
  def self.subcommand_help(cmd); end
  def self.subcommands; end
  def self.subtask(subcommand, subcommand_class); end
  def self.subtask_help(cmd); end
  def self.subtasks; end
  def self.task_help(shell, command_name); end
  extend Bundler::Thor::Base::ClassMethods
  extend Bundler::Thor::Invocation::ClassMethods
  include Bundler::Thor::Base
  include Bundler::Thor::Invocation
  include Bundler::Thor::Shell
end
class Anonymous_Struct_1 < Struct
  def ancestor_name; end
  def ancestor_name=(_); end
  def description; end
  def description=(_); end
  def long_description; end
  def long_description=(_); end
  def name; end
  def name=(_); end
  def options; end
  def options=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
  def usage; end
  def usage=(_); end
end
class Bundler::Thor::Command < Anonymous_Struct_1
  def formatted_usage(klass, namespace = nil, subcommand = nil); end
  def handle_argument_error?(instance, error, caller); end
  def handle_no_method_error?(instance, error, caller); end
  def hidden?; end
  def initialize(name, description, long_description, usage, options = nil); end
  def initialize_copy(other); end
  def local_method?(instance, name); end
  def not_debugging?(instance); end
  def private_method?(instance); end
  def public_method?(instance); end
  def required_arguments_for(klass, usage); end
  def required_options; end
  def run(instance, args = nil); end
  def sans_backtrace(backtrace, caller); end
end
class Bundler::Thor::HiddenCommand < Bundler::Thor::Command
  def hidden?; end
end
class Bundler::Thor::DynamicCommand < Bundler::Thor::Command
  def initialize(name, options = nil); end
  def run(instance, args = nil); end
end
module Bundler::Thor::CoreExt
end
class Bundler::Thor::CoreExt::HashWithIndifferentAccess < Hash
  def [](key); end
  def []=(key, value); end
  def convert_key(key); end
  def delete(key); end
  def fetch(key, *args); end
  def initialize(hash = nil); end
  def key?(key); end
  def merge!(other); end
  def merge(other); end
  def method_missing(method, *args); end
  def replace(other_hash); end
  def reverse_merge!(other_hash); end
  def reverse_merge(other); end
  def to_hash; end
  def values_at(*indices); end
end
class Bundler::Thor::NoKwargSpellChecker < DidYouMean::SpellChecker
  def initialize(dictionary); end
end
class Bundler::Thor::Error < StandardError
end
class Bundler::Thor::UndefinedCommandError < Bundler::Thor::Error
  def all_commands; end
  def command; end
  def initialize(command, all_commands, namespace); end
end
class Bundler::Thor::UndefinedCommandError::SpellChecker
  def corrections; end
  def error; end
  def initialize(error); end
  def spell_checker; end
end
class Bundler::Thor::AmbiguousCommandError < Bundler::Thor::Error
end
class Bundler::Thor::InvocationError < Bundler::Thor::Error
end
class Bundler::Thor::UnknownArgumentError < Bundler::Thor::Error
  def initialize(switches, unknown); end
  def switches; end
  def unknown; end
end
class Bundler::Thor::UnknownArgumentError::SpellChecker
  def corrections; end
  def error; end
  def initialize(error); end
  def spell_checker; end
end
class Bundler::Thor::RequiredArgumentMissingError < Bundler::Thor::InvocationError
end
class Bundler::Thor::MalformattedArgumentError < Bundler::Thor::InvocationError
end
module Bundler::Thor::Invocation
  def _parse_initialization_options(args, opts, config); end
  def _retrieve_class_and_command(name, sent_command = nil); end
  def _retrieve_class_and_task(name, sent_command = nil); end
  def _shared_configuration; end
  def current_command_chain; end
  def initialize(args = nil, options = nil, config = nil, &block); end
  def invoke(name = nil, *args); end
  def invoke_all; end
  def invoke_command(command, *args); end
  def invoke_task(command, *args); end
  def invoke_with_padding(*args); end
  def self.included(base); end
end
module Bundler::Thor::Invocation::ClassMethods
  def prepare_for_invocation(key, name); end
end
class Bundler::Thor::NestedContext
  def enter; end
  def entered?; end
  def initialize; end
  def pop; end
  def push; end
end
class Bundler::Thor::Argument
  def banner; end
  def default; end
  def default_banner; end
  def description; end
  def enum; end
  def human_name; end
  def initialize(name, options = nil); end
  def name; end
  def required; end
  def required?; end
  def show_default?; end
  def type; end
  def usage; end
  def valid_type?(type); end
  def validate!; end
end
class Bundler::Thor::Arguments
  def check_requirement!; end
  def current_is_value?; end
  def initialize(arguments = nil); end
  def last?; end
  def no_or_skip?(arg); end
  def parse(args); end
  def parse_array(name); end
  def parse_hash(name); end
  def parse_numeric(name); end
  def parse_string(name); end
  def peek; end
  def remaining; end
  def self.parse(*args); end
  def self.split(args); end
  def shift; end
  def unshift(arg); end
end
class Bundler::Thor::Option < Bundler::Thor::Argument
  def aliases; end
  def array?; end
  def boolean?; end
  def dasherize(str); end
  def dasherized?; end
  def group; end
  def hash?; end
  def hide; end
  def human_name; end
  def initialize(name, options = nil); end
  def lazy_default; end
  def numeric?; end
  def repeatable; end
  def self.parse(key, value); end
  def string?; end
  def switch_name; end
  def undasherize(str); end
  def usage(padding = nil); end
  def validate!; end
  def validate_default_type!; end
end
class Bundler::Thor::Options < Bundler::Thor::Arguments
  def assign_result!(option, result); end
  def check_unknown!; end
  def current_is_switch?; end
  def current_is_switch_formatted?; end
  def current_is_value?; end
  def initialize(hash_options = nil, defaults = nil, stop_on_unknown = nil, disable_required_check = nil); end
  def normalize_switch(arg); end
  def parse(args); end
  def parse_boolean(switch); end
  def parse_peek(switch, option); end
  def parsing_options?; end
  def peek; end
  def remaining; end
  def self.to_switches(options); end
  def switch?(arg); end
  def switch_option(arg); end
end
module Bundler::Thor::Base
  def args; end
  def args=(arg0); end
  def initialize(args = nil, local_options = nil, config = nil); end
  def options; end
  def options=(arg0); end
  def parent_options; end
  def parent_options=(arg0); end
  def self.included(base); end
  def self.register_klass_file(klass); end
  def self.shell; end
  def self.shell=(arg0); end
  def self.subclass_files; end
  def self.subclasses; end
end
module Bundler::Thor::Shell
  def _shared_configuration; end
  def ask(*args, &block); end
  def error(*args, &block); end
  def file_collision(*args, &block); end
  def initialize(args = nil, options = nil, config = nil); end
  def no?(*args, &block); end
  def print_in_columns(*args, &block); end
  def print_table(*args, &block); end
  def print_wrapped(*args, &block); end
  def say(*args, &block); end
  def say_status(*args, &block); end
  def set_color(*args, &block); end
  def shell; end
  def shell=(arg0); end
  def terminal_width(*args, &block); end
  def with_padding; end
  def yes?(*args, &block); end
end
module Bundler::Thor::LineEditor
  def self.best_available; end
  def self.readline(prompt, options = nil); end
end
class Bundler::Thor::LineEditor::Basic
  def echo?; end
  def get_input; end
  def initialize(prompt, options); end
  def options; end
  def prompt; end
  def readline; end
  def self.available?; end
end
class Bundler::Thor::LineEditor::Readline < Bundler::Thor::LineEditor::Basic
  def add_to_history?; end
  def completion_options; end
  def completion_proc; end
  def readline; end
  def self.available?; end
  def use_path_completion?; end
end
class Bundler::Thor::LineEditor::Readline::PathCompletion
  def absolute_matches; end
  def base_path; end
  def glob_pattern; end
  def initialize(text); end
  def matches; end
  def relative_matches; end
  def text; end
end
module Bundler::Thor::Sandbox
end
module Bundler::Thor::Util
  def self.camel_case(str); end
  def self.escape_globs(path); end
  def self.escape_html(string); end
  def self.find_by_namespace(namespace); end
  def self.find_class_and_command_by_namespace(namespace, fallback = nil); end
  def self.find_class_and_task_by_namespace(namespace, fallback = nil); end
  def self.globs_for(path); end
  def self.load_thorfile(path, content = nil, debug = nil); end
  def self.namespace_from_thor_class(constant); end
  def self.namespaces_in_content(contents, file = nil); end
  def self.ruby_command; end
  def self.snake_case(str); end
  def self.thor_classes_in(klass); end
  def self.thor_root; end
  def self.thor_root_glob; end
  def self.user_home; end
end
module Bundler::Thor::Base::ClassMethods
  def all_commands; end
  def all_tasks; end
  def allow_incompatible_default_type!; end
  def argument(name, options = nil); end
  def arguments; end
  def attr_accessor(*arg0); end
  def attr_reader(*arg0); end
  def attr_writer(*arg0); end
  def baseclass; end
  def basename; end
  def build_option(name, options, scope); end
  def build_options(options, scope); end
  def check_default_type!; end
  def check_default_type; end
  def check_unknown_options!; end
  def check_unknown_options; end
  def check_unknown_options?(config); end
  def class_option(name, options = nil); end
  def class_options(options = nil); end
  def class_options_help(shell, groups = nil); end
  def commands; end
  def create_command(meth); end
  def create_task(meth); end
  def disable_required_check?(command_name); end
  def dispatch(command, given_args, given_opts, config); end
  def exit_on_failure?; end
  def find_and_refresh_command(name); end
  def find_and_refresh_task(name); end
  def from_superclass(method, default = nil); end
  def group(name = nil); end
  def handle_argument_error(command, error, args, arity); end
  def handle_no_command_error(command, has_namespace = nil); end
  def handle_no_task_error(command, has_namespace = nil); end
  def inherited(klass); end
  def initialize_added; end
  def is_thor_reserved_word?(word, type); end
  def method_added(meth); end
  def namespace(name = nil); end
  def no_commands(&block); end
  def no_commands?; end
  def no_commands_context; end
  def no_tasks(&block); end
  def print_options(shell, options, group_name = nil); end
  def public_command(*names); end
  def public_task(*names); end
  def remove_argument(*names); end
  def remove_class_option(*names); end
  def remove_command(*names); end
  def remove_task(*names); end
  def start(given_args = nil, config = nil); end
  def stop_on_unknown_option?(command_name); end
  def strict_args_position!; end
  def strict_args_position; end
  def strict_args_position?(config); end
  def tasks; end
end
class Bundler::UI::Shell
  def add_color(string, *color); end
  def ask(msg); end
  def confirm(msg, newline = nil); end
  def debug(msg, newline = nil); end
  def debug?; end
  def error(msg, newline = nil); end
  def info(msg, newline = nil); end
  def initialize(options = nil); end
  def level(name = nil); end
  def level=(level); end
  def no?; end
  def quiet?; end
  def shell=(arg0); end
  def silence(&blk); end
  def strip_leading_spaces(text); end
  def tell_err(message, color = nil, newline = nil); end
  def tell_me(msg, color = nil, newline = nil); end
  def trace(e, newline = nil, force = nil); end
  def unprinted_warnings; end
  def warn(msg, newline = nil); end
  def with_level(level); end
  def word_wrap(text, line_width = nil); end
  def yes?(msg); end
end
class Bundler::Thor::Shell::Basic
  def answer_match(possibilities, answer, case_insensitive); end
  def as_unicode; end
  def ask(statement, *args); end
  def ask_filtered(statement, color, options); end
  def ask_simply(statement, color, options); end
  def base; end
  def base=(arg0); end
  def can_display_colors?; end
  def dynamic_width; end
  def dynamic_width_stty; end
  def dynamic_width_tput; end
  def error(statement); end
  def file_collision(destination); end
  def file_collision_help; end
  def git_merge_tool; end
  def indent(count = nil); end
  def initialize; end
  def is?(value); end
  def lookup_color(color); end
  def merge(destination, content); end
  def merge_tool; end
  def mute; end
  def mute?; end
  def no?(statement, color = nil); end
  def padding; end
  def padding=(value); end
  def prepare_message(message, *color); end
  def print_in_columns(array); end
  def print_table(array, options = nil); end
  def print_wrapped(message, options = nil); end
  def quiet?; end
  def say(message = nil, color = nil, force_new_line = nil); end
  def say_status(status, message, log_status = nil); end
  def set_color(string, *arg1); end
  def show_diff(destination, content); end
  def stderr; end
  def stdout; end
  def terminal_width; end
  def truncate(string, width); end
  def unix?; end
  def yes?(statement, color = nil); end
end
class Bundler::Thor::Shell::Color < Bundler::Thor::Shell::Basic
  def are_colors_disabled?; end
  def can_display_colors?; end
  def diff_lcs_loaded?; end
  def output_diff_line(diff); end
  def set_color(string, *colors); end
  def show_diff(destination, content); end
end
class Bundler::UI::RGProxy < Gem::SilentUI
  def initialize(ui); end
  def say(message); end
end
class Bundler::Settings
  def [](name); end
  def all; end
  def allow_sudo?; end
  def app_cache_path; end
  def array_to_s(array); end
  def converted_value(value, key); end
  def credentials_for(uri); end
  def gem_mirrors; end
  def global_config_file; end
  def ignore_config?; end
  def initialize(root = nil); end
  def is_array(key); end
  def is_bool(name); end
  def is_num(key); end
  def key_for(key); end
  def load_config(config_file); end
  def local_config_file; end
  def local_overrides; end
  def locations(key); end
  def mirror_for(uri); end
  def parent_setting_for(name); end
  def path; end
  def pretty_values_for(exposed_key); end
  def self.normalize_uri(uri); end
  def set_command_option(key, value); end
  def set_command_option_if_given(key, value); end
  def set_global(key, value); end
  def set_key(raw_key, value, hash, file); end
  def set_local(key, value); end
  def specific_gem_for(name); end
  def split_specific_setting_for(name); end
  def temporary(update); end
  def to_array(value); end
  def to_bool(value); end
  def validate!; end
end
class Bundler::Settings::Path < Struct
  def base_path; end
  def base_path_relative_to_pwd; end
  def default_install_uses_path; end
  def default_install_uses_path=(_); end
  def explicit_path; end
  def explicit_path=(_); end
  def path; end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
  def system_path; end
  def system_path=(_); end
  def use_system_gems?; end
  def validate!; end
end
class Bundler::FeatureFlag
  def allow_bundler_dependency_conflicts?; end
  def allow_offline_install?; end
  def auto_clean_without_path?; end
  def auto_config_jobs?; end
  def bundler_10_mode?; end
  def bundler_1_mode?; end
  def bundler_2_mode?; end
  def bundler_3_mode?; end
  def bundler_4_mode?; end
  def bundler_5_mode?; end
  def bundler_6_mode?; end
  def bundler_7_mode?; end
  def bundler_8_mode?; end
  def bundler_9_mode?; end
  def cache_all?; end
  def default_cli_command; end
  def default_install_uses_path?; end
  def deployment_means_frozen?; end
  def disable_multisource?; end
  def forget_cli_options?; end
  def global_gem_cache?; end
  def initialize(bundler_version); end
  def major_version; end
  def only_update_to_newer_versions?; end
  def path_relative_to_cwd?; end
  def plugins?; end
  def print_only_version_number?; end
  def self.settings_flag(flag, &default); end
  def self.settings_method(name, key, &default); end
  def self.settings_option(key, &default); end
  def setup_makes_kernel_gem_public?; end
  def skip_default_git_sources?; end
  def specific_platform?; end
  def suppress_install_using_messages?; end
  def unlock_source_unlocks_spec?; end
  def update_requires_all_flag?; end
  def use_gem_version_promoter_for_major_updates?; end
end
class Bundler::Source
  def can_lock?(spec); end
  def dependency_names; end
  def dependency_names=(arg0); end
  def dependency_names_to_double_check; end
  def double_check_for(*arg0); end
  def earlier_version?(spec_version, locked_spec_version); end
  def extension_cache_path(spec); end
  def extension_cache_slug(_); end
  def include?(other); end
  def inspect; end
  def path?; end
  def print_using_message(message); end
  def unmet_deps; end
  def version_color(spec_version, locked_spec_version); end
  def version_message(spec); end
end
class Bundler::Source::Path < Bundler::Source
  def ==(other); end
  def app_cache_dirname; end
  def app_cache_path(custom_path = nil); end
  def cache(spec, custom_path = nil); end
  def cached!; end
  def eql?(other); end
  def expand(somepath); end
  def expanded_original_path; end
  def expanded_path; end
  def generate_bin(spec, options = nil); end
  def has_app_cache?; end
  def hash; end
  def initialize(options); end
  def install(spec, options = nil); end
  def load_gemspec(file); end
  def load_spec_files; end
  def local_specs(*arg0); end
  def lockfile_path; end
  def name; end
  def name=(arg0); end
  def options; end
  def original_path; end
  def path; end
  def relative_path(path = nil); end
  def remote!; end
  def root; end
  def root_path; end
  def self.from_lock(options); end
  def specs; end
  def to_lock; end
  def to_s; end
  def validate_spec(spec); end
  def version; end
  def version=(arg0); end
end
class Bundler::Source::Git < Bundler::Source::Path
  def ==(other); end
  def allow_git_ops?; end
  def app_cache_dirname; end
  def base_name; end
  def branch; end
  def cache(spec, custom_path = nil); end
  def cache_path; end
  def cached?; end
  def cached_revision; end
  def cached_revision_checked_out?; end
  def eql?(other); end
  def extension_cache_slug(_); end
  def extension_dir_name; end
  def fetch; end
  def git_proxy; end
  def git_scope; end
  def glob; end
  def has_app_cache?; end
  def hash; end
  def initialize(options); end
  def install(spec, options = nil); end
  def install_path; end
  def load_gemspec(file); end
  def load_spec_files; end
  def local?; end
  def local_override!(path); end
  def name; end
  def options; end
  def override_for(path); end
  def path; end
  def ref; end
  def requires_checkout?; end
  def revision; end
  def self.from_lock(options); end
  def serialize_gemspecs_in(destination); end
  def set_local!(path); end
  def shortref_for_display(ref); end
  def shortref_for_path(ref); end
  def specs(*arg0); end
  def submodules; end
  def to_lock; end
  def to_s; end
  def unlock!; end
  def uri; end
  def uri_hash; end
  def validate_spec(_spec); end
end
class Bundler::Source::Rubygems < Bundler::Source
  def ==(other); end
  def add_remote(source); end
  def api_fetchers; end
  def builtin_gem?(spec); end
  def cache(spec, custom_path = nil); end
  def cache_globally(spec, local_cache_path); end
  def cache_path; end
  def cached!; end
  def cached_built_in_gem(spec); end
  def cached_gem(spec); end
  def cached_path(spec); end
  def cached_specs; end
  def caches; end
  def can_lock?(spec); end
  def credless_remotes; end
  def dependency_names_to_double_check; end
  def double_check_for(unmet_dependency_names); end
  def download_cache_path(spec); end
  def download_gem(spec, download_path); end
  def eql?(other); end
  def equivalent_remotes?(other_remotes); end
  def extension_cache_slug(spec); end
  def fetch_gem(spec); end
  def fetch_names(fetchers, dependency_names, index, override_dupes); end
  def fetchers; end
  def hash; end
  def include?(o); end
  def initialize(options = nil); end
  def install(spec, opts = nil); end
  def installed?(spec); end
  def installed_specs; end
  def loaded_from(spec); end
  def name; end
  def normalize_uri(uri); end
  def options; end
  def remote!; end
  def remote_specs; end
  def remotes; end
  def remotes_for_spec(spec); end
  def remove_auth(remote); end
  def replace_remotes(other_remotes, allow_equivalent = nil); end
  def requires_sudo?; end
  def rubygems_dir; end
  def self.from_lock(options); end
  def specs; end
  def suppress_configured_credentials(remote); end
  def to_lock; end
  def to_s; end
  def unmet_deps; end
end
class Bundler::LockfileParser
  def bundler_version; end
  def dependencies; end
  def initialize(lockfile); end
  def parse_bundled_with(line); end
  def parse_dependency(line); end
  def parse_platform(line); end
  def parse_ruby(line); end
  def parse_source(line); end
  def parse_spec(line); end
  def platforms; end
  def ruby_version; end
  def self.sections_in_lockfile(lockfile_contents); end
  def self.sections_to_ignore(base_version = nil); end
  def self.unknown_sections_in_lockfile(lockfile_contents); end
  def sources; end
  def specs; end
  def warn_for_outdated_bundler_version; end
end
class Bundler::Definition
  def add_current_platform; end
  def add_platform(platform); end
  def additional_base_requirements_for_resolve; end
  def change_reason; end
  def compute_requires; end
  def concat_ruby_version_requirements(ruby_version, ruby_versions = nil); end
  def converge_dependencies; end
  def converge_locals; end
  def converge_locked_specs; end
  def converge_path_source_to_gemspec_source(source); end
  def converge_path_sources_to_gemspec_sources; end
  def converge_paths; end
  def converge_rubygems_sources; end
  def converge_sources; end
  def current_dependencies; end
  def current_platforms; end
  def dependencies; end
  def dependencies_for_source_changed?(source, locked_source = nil); end
  def double_check_for_index(idx, dependency_names); end
  def ensure_equivalent_gemfile_and_lockfile(explicit_flag = nil); end
  def equivalent_rubygems_remotes?(source); end
  def expand_dependencies(dependencies, remote = nil); end
  def expanded_dependencies; end
  def extract_gem_info(error); end
  def find_indexed_specs(current_spec); end
  def find_resolved_spec(current_spec); end
  def gem_version_promoter; end
  def gemfiles; end
  def groups; end
  def has_local_dependencies?; end
  def has_rubygems_remotes?; end
  def in_locked_deps?(dep, locked_dep); end
  def index; end
  def initialize(lockfile, dependencies, sources, unlock, ruby_version = nil, optional_groups = nil, gemfiles = nil); end
  def lock(file, preserve_unknown_sections = nil); end
  def locked_bundler_version; end
  def locked_deps; end
  def locked_gems; end
  def locked_ruby_version; end
  def locked_ruby_version_object; end
  def lockfile; end
  def lockfiles_equal?(current, proposed, preserve_unknown_sections); end
  def metadata_dependencies; end
  def missing_specs; end
  def missing_specs?; end
  def new_platform?; end
  def new_specs; end
  def nothing_changed?; end
  def pinned_spec_names(skip = nil); end
  def platforms; end
  def pretty_dep(dep, source = nil); end
  def remove_platform(platform); end
  def removed_specs; end
  def requested_dependencies; end
  def requested_groups; end
  def requested_specs; end
  def requires; end
  def resolve; end
  def resolve_remotely!; end
  def resolve_with_cache!; end
  def ruby_version; end
  def satisfies_locked_spec?(dep); end
  def self.build(gemfile, lockfile, unlock); end
  def source_requirements; end
  def sources; end
  def spec_git_paths; end
  def specs; end
  def specs_changed?(source); end
  def specs_for(groups); end
  def specs_for_source_changed?(source); end
  def to_lock; end
  def unlocking?; end
  def validate_platforms!; end
  def validate_ruby!; end
  def validate_runtime!; end
  include Bundler::GemHelpers
end
class Bundler::Dependency < Gem::Dependency
  def autorequire; end
  def branch; end
  def current_env?; end
  def current_platform?; end
  def expanded_platforms; end
  def gem_platforms(valid_platforms); end
  def gemfile; end
  def git; end
  def groups; end
  def initialize(name, version, options = nil, &blk); end
  def platforms; end
  def should_include?; end
  def specific?; end
  def to_lock; end
end
module Bundler::RubyDsl
  def ruby(*ruby_version); end
end
class Bundler::Dsl
  def add_git_sources; end
  def check_primary_source_safety(source_list); end
  def dependencies; end
  def dependencies=(arg0); end
  def env(name); end
  def eval_gemfile(gemfile, contents = nil); end
  def gem(name, *args); end
  def gemfile_root; end
  def gemspec(opts = nil); end
  def gemspecs; end
  def git(uri, options = nil, &blk); end
  def git_source(name, &block); end
  def github(repo, options = nil); end
  def group(*args, &blk); end
  def initialize; end
  def install_if(*args); end
  def method_missing(name, *args); end
  def normalize_group_options(opts, groups); end
  def normalize_hash(opts); end
  def normalize_options(name, version, opts); end
  def normalize_source(source); end
  def path(path, options = nil, &blk); end
  def platform(*platforms); end
  def platforms(*platforms); end
  def plugin(*args); end
  def self.evaluate(gemfile, lockfile, unlock); end
  def source(source, *args, &blk); end
  def to_definition(lockfile, unlock); end
  def valid_keys; end
  def validate_keys(command, opts, valid_keys); end
  def warn_deprecated_git_source(name, replacement, additional_message = nil); end
  def with_source(source); end
  include Bundler::RubyDsl
end
class Bundler::Dsl::DSLError < Bundler::GemfileError
  def backtrace; end
  def contents; end
  def description; end
  def dsl_path; end
  def initialize(description, dsl_path, backtrace, contents = nil); end
  def parse_line_number_from_description; end
  def status_code; end
  def to_s; end
end
class Bundler::SourceList
  def add_git_source(options = nil); end
  def add_path_source(options = nil); end
  def add_plugin_source(source, options = nil); end
  def add_rubygems_remote(uri); end
  def add_rubygems_source(options = nil); end
  def add_source_to_list(source, list); end
  def all_sources; end
  def cached!; end
  def combine_rubygems_sources; end
  def default_source; end
  def equal_source?(source, other_source); end
  def equal_sources?(lock_sources, replacement_sources); end
  def equivalent_rubygems_sources?(lock_sources, replacement_sources); end
  def equivalent_source?(source, other_source); end
  def equivalent_sources?(lock_sources, replacement_sources); end
  def get(source); end
  def git_sources; end
  def global_rubygems_source; end
  def global_rubygems_source=(uri); end
  def initialize; end
  def lock_sources; end
  def metadata_source; end
  def path_sources; end
  def plugin_sources; end
  def remote!; end
  def replace_sources!(replacement_sources); end
  def rubygems_aggregate_class; end
  def rubygems_primary_remotes; end
  def rubygems_remotes; end
  def rubygems_sources; end
  def source_list_for(source); end
  def warn_on_git_protocol(source); end
end
class Bundler::Source::Metadata < Bundler::Source
  def ==(other); end
  def cached!; end
  def eql?(other); end
  def hash; end
  def install(spec, _opts = nil); end
  def options; end
  def remote!; end
  def specs; end
  def to_s; end
  def version_message(spec); end
end
module Bundler::URI
  def self.decode_www_form(str, enc = nil, separator: nil, use__charset_: nil, isindex: nil); end
  def self.decode_www_form_component(str, enc = nil); end
  def self.encode_www_form(enum, enc = nil); end
  def self.encode_www_form_component(str, enc = nil); end
  def self.extract(str, schemes = nil, &block); end
  def self.get_encoding(label); end
  def self.join(*str); end
  def self.parse(uri); end
  def self.regexp(schemes = nil); end
  def self.scheme_list; end
  def self.split(uri); end
  extend Bundler::URI::Escape
  include Bundler::URI::RFC2396_REGEXP
end
module Bundler::URI::RFC2396_REGEXP
end
module Bundler::URI::RFC2396_REGEXP::PATTERN
end
class Bundler::URI::RFC2396_Parser
  def convert_to_uri(uri); end
  def escape(str, unsafe = nil); end
  def extract(str, schemes = nil); end
  def initialize(opts = nil); end
  def initialize_pattern(opts = nil); end
  def initialize_regexp(pattern); end
  def inspect; end
  def join(*uris); end
  def make_regexp(schemes = nil); end
  def parse(uri); end
  def pattern; end
  def regexp; end
  def split(uri); end
  def unescape(str, escaped = nil); end
  include Bundler::URI::RFC2396_REGEXP
end
class Bundler::URI::RFC3986_Parser
  def convert_to_uri(uri); end
  def default_regexp; end
  def initialize; end
  def inspect; end
  def join(*uris); end
  def parse(uri); end
  def regexp; end
  def split(uri); end
end
module Bundler::URI::Util
  def make_components_hash(klass, array_hash); end
  def self.make_components_hash(klass, array_hash); end
end
module Bundler::URI::Escape
  def decode(*arg); end
  def encode(*arg); end
  def escape(*arg); end
  def unescape(*arg); end
end
class Bundler::URI::Error < StandardError
end
class Bundler::URI::InvalidURIError < Bundler::URI::Error
end
class Bundler::URI::InvalidComponentError < Bundler::URI::Error
end
class Bundler::URI::BadURIError < Bundler::URI::Error
end
class Bundler::URI::Generic
  def +(oth); end
  def -(oth); end
  def ==(oth); end
  def absolute; end
  def absolute?; end
  def check_host(v); end
  def check_opaque(v); end
  def check_password(v, user = nil); end
  def check_path(v); end
  def check_port(v); end
  def check_registry(v); end
  def check_scheme(v); end
  def check_user(v); end
  def check_userinfo(user, password = nil); end
  def coerce(oth); end
  def component; end
  def component_ary; end
  def default_port; end
  def eql?(oth); end
  def escape_userpass(v); end
  def find_proxy(env = nil); end
  def fragment; end
  def fragment=(v); end
  def hash; end
  def hierarchical?; end
  def host; end
  def host=(v); end
  def hostname; end
  def hostname=(v); end
  def initialize(scheme, userinfo, host, port, registry, path, opaque, query, fragment, parser = nil, arg_check = nil); end
  def inspect; end
  def merge!(oth); end
  def merge(oth); end
  def merge_path(base, rel); end
  def normalize!; end
  def normalize; end
  def opaque; end
  def opaque=(v); end
  def parser; end
  def password; end
  def password=(password); end
  def path; end
  def path=(v); end
  def port; end
  def port=(v); end
  def query; end
  def query=(v); end
  def registry; end
  def registry=(v); end
  def relative?; end
  def replace!(oth); end
  def route_from(oth); end
  def route_from0(oth); end
  def route_from_path(src, dst); end
  def route_to(oth); end
  def scheme; end
  def scheme=(v); end
  def select(*components); end
  def self.build(args); end
  def self.build2(args); end
  def self.component; end
  def self.default_port; end
  def self.use_proxy?(hostname, addr, port, no_proxy); end
  def self.use_registry; end
  def set_host(v); end
  def set_opaque(v); end
  def set_password(v); end
  def set_path(v); end
  def set_port(v); end
  def set_registry(v); end
  def set_scheme(v); end
  def set_user(v); end
  def set_userinfo(user, password = nil); end
  def split_path(path); end
  def split_userinfo(ui); end
  def to_s; end
  def user; end
  def user=(user); end
  def userinfo; end
  def userinfo=(userinfo); end
  include Bundler::URI
end
class Bundler::URI::File < Bundler::URI::Generic
  def check_password(user); end
  def check_user(user); end
  def check_userinfo(user); end
  def self.build(args); end
  def set_host(v); end
  def set_password(v); end
  def set_port(v); end
  def set_user(v); end
  def set_userinfo(v); end
end
class Bundler::URI::FTP < Bundler::URI::Generic
  def check_typecode(v); end
  def initialize(scheme, userinfo, host, port, registry, path, opaque, query, fragment, parser = nil, arg_check = nil); end
  def merge(oth); end
  def path; end
  def self.build(args); end
  def self.new2(user, password, host, port, path, typecode = nil, arg_check = nil); end
  def set_path(v); end
  def set_typecode(v); end
  def to_s; end
  def typecode; end
  def typecode=(typecode); end
end
class Bundler::URI::HTTP < Bundler::URI::Generic
  def request_uri; end
  def self.build(args); end
end
class Bundler::URI::HTTPS < Bundler::URI::HTTP
end
class Bundler::URI::LDAP < Bundler::URI::Generic
  def attributes; end
  def attributes=(val); end
  def build_path_query; end
  def dn; end
  def dn=(val); end
  def extensions; end
  def extensions=(val); end
  def filter; end
  def filter=(val); end
  def hierarchical?; end
  def initialize(*arg); end
  def parse_dn; end
  def parse_query; end
  def scope; end
  def scope=(val); end
  def self.build(args); end
  def set_attributes(val); end
  def set_dn(val); end
  def set_extensions(val); end
  def set_filter(val); end
  def set_scope(val); end
end
class Bundler::URI::LDAPS < Bundler::URI::LDAP
end
class Bundler::URI::MailTo < Bundler::URI::Generic
  def check_headers(v); end
  def check_to(v); end
  def headers; end
  def headers=(v); end
  def initialize(*arg); end
  def self.build(args); end
  def set_headers(v); end
  def set_to(v); end
  def to; end
  def to=(v); end
  def to_mailtext; end
  def to_rfc822text; end
  def to_s; end
  include Bundler::URI::RFC2396_REGEXP
end
class Bundler::Index
  def <<(spec); end
  def ==(other); end
  def [](query, base = nil); end
  def add_source(index); end
  def all_specs; end
  def dependencies_eql?(spec, other_spec); end
  def dependency_names; end
  def each(&blk); end
  def empty?; end
  def initialize; end
  def initialize_copy(o); end
  def inspect; end
  def local_search(query, base = nil); end
  def search(query, base = nil); end
  def search_all(name); end
  def search_by_dependency(dependency, base = nil); end
  def search_by_spec(spec); end
  def self.build; end
  def self.sort_specs(specs); end
  def size; end
  def sort_specs(specs); end
  def sources; end
  def spec_names; end
  def specs; end
  def specs_by_name(name); end
  def unmet_dependency_names; end
  def unsorted_search(query, base); end
  def use(other, override_dupes = nil); end
  include Enumerable
end
class Bundler::Source::Gemspec < Bundler::Source::Path
  def as_path_source; end
  def gemspec; end
  def initialize(options); end
end
class Bundler::LazySpecification
  def ==(other); end
  def __materialize__; end
  def dependencies; end
  def full_name; end
  def git_version; end
  def identifier; end
  def initialize(name, version, platform, source = nil); end
  def method_missing(method, *args, &blk); end
  def name; end
  def platform; end
  def remote; end
  def remote=(arg0); end
  def respond_to?(*args); end
  def satisfies?(dependency); end
  def source; end
  def source=(arg0); end
  def to_ary; end
  def to_lock; end
  def to_s; end
  def version; end
  include Bundler::MatchPlatform
end
class Bundler::LazySpecification::Identifier < Struct
  def <=>(other); end
  def dependencies; end
  def dependencies=(_); end
  def name; end
  def name=(_); end
  def platform; end
  def platform=(_); end
  def platform_string; end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
  def source; end
  def source=(_); end
  def version; end
  def version=(_); end
  include Comparable
end
class Bundler::SpecSet
  def <<(spec); end
  def [](key); end
  def []=(key, value); end
  def each(&b); end
  def empty?; end
  def extract_circular_gems(error); end
  def find_by_name_and_platform(name, platform); end
  def for(dependencies, skip = nil, check = nil, match_current_platform = nil, raise_on_missing = nil); end
  def initialize(specs); end
  def length; end
  def lookup; end
  def materialize(deps, missing_specs = nil); end
  def materialized_for_all_platforms; end
  def merge(set); end
  def size; end
  def sort!; end
  def sorted; end
  def spec_for_dependency(dep, match_current_platform); end
  def to_a; end
  def to_hash; end
  def tsort_each_child(s); end
  def tsort_each_node; end
  def valid_for?(deps); end
  def what_required(spec); end
  include Enumerable
  include TSort
end
class Gem::Licenses
  def self.match?(license); end
  def self.suggestions(license); end
  extend Gem::Text
end
class Bundler::RemoteSpecification
  def <=>(other); end
  def __swap__(spec); end
  def _remote_specification; end
  def dependencies; end
  def dependencies=(arg0); end
  def fetch_platform; end
  def full_name; end
  def git_version; end
  def initialize(name, version, platform, spec_fetcher); end
  def method_missing(method, *args, &blk); end
  def name; end
  def platform; end
  def remote; end
  def remote=(arg0); end
  def respond_to?(method, include_all = nil); end
  def sort_obj; end
  def source; end
  def source=(arg0); end
  def to_ary; end
  def to_s; end
  def version; end
  include Bundler::MatchPlatform
  include Comparable
end
module Bundler::Molinillo
end
module Bundler::Molinillo::Compatibility
  def flat_map(enum, &blk); end
  def self.flat_map(enum, &blk); end
end
module Bundler::Molinillo::Delegates
end
module Bundler::Molinillo::Delegates::SpecificationProvider
  def allow_missing?(dependency); end
  def dependencies_for(specification); end
  def name_for(dependency); end
  def name_for_explicit_dependency_source; end
  def name_for_locking_dependency_source; end
  def requirement_satisfied_by?(requirement, activated, spec); end
  def search_for(dependency); end
  def sort_dependencies(dependencies, activated, conflicts); end
  def with_no_such_dependency_error_handling; end
end
class Bundler::Molinillo::ResolverError < StandardError
end
class Bundler::Molinillo::NoSuchDependencyError < Bundler::Molinillo::ResolverError
  def dependency; end
  def dependency=(arg0); end
  def initialize(dependency, required_by = nil); end
  def message; end
  def required_by; end
  def required_by=(arg0); end
end
class Bundler::Molinillo::CircularDependencyError < Bundler::Molinillo::ResolverError
  def dependencies; end
  def initialize(vertices); end
end
class Bundler::Molinillo::VersionConflict < Bundler::Molinillo::ResolverError
  def conflicts; end
  def initialize(conflicts, specification_provider); end
  def message_with_trees(opts = nil); end
  def specification_provider; end
  include Bundler::Molinillo::Delegates::SpecificationProvider
end
class Bundler::Molinillo::DependencyGraph
  def ==(other); end
  def add_child_vertex(name, payload, parent_names, requirement); end
  def add_edge(origin, destination, requirement); end
  def add_edge_no_circular(origin, destination, requirement); end
  def add_vertex(name, payload, root = nil); end
  def delete_edge(edge); end
  def detach_vertex_named(name); end
  def each; end
  def initialize; end
  def initialize_copy(other); end
  def inspect; end
  def log; end
  def rewind_to(tag); end
  def root_vertex_named(name); end
  def self.tsort(vertices); end
  def set_payload(name, payload); end
  def tag(tag); end
  def to_dot(options = nil); end
  def tsort_each_child(vertex, &block); end
  def tsort_each_node; end
  def vertex_named(name); end
  def vertices; end
  include Enumerable
  include TSort
end
class Bundler::Molinillo::DependencyGraph::Action
  def down(graph); end
  def next; end
  def next=(arg0); end
  def previous; end
  def previous=(arg0); end
  def self.action_name; end
  def up(graph); end
end
class Bundler::Molinillo::DependencyGraph::AddEdgeNoCircular < Bundler::Molinillo::DependencyGraph::Action
  def delete_first(array, item); end
  def destination; end
  def down(graph); end
  def initialize(origin, destination, requirement); end
  def make_edge(graph); end
  def origin; end
  def requirement; end
  def self.action_name; end
  def up(graph); end
end
class Bundler::Molinillo::DependencyGraph::AddVertex < Bundler::Molinillo::DependencyGraph::Action
  def down(graph); end
  def initialize(name, payload, root); end
  def name; end
  def payload; end
  def root; end
  def self.action_name; end
  def up(graph); end
end
class Bundler::Molinillo::DependencyGraph::DeleteEdge < Bundler::Molinillo::DependencyGraph::Action
  def destination_name; end
  def down(graph); end
  def initialize(origin_name, destination_name, requirement); end
  def make_edge(graph); end
  def origin_name; end
  def requirement; end
  def self.action_name; end
  def up(graph); end
end
class Bundler::Molinillo::DependencyGraph::DetachVertexNamed < Bundler::Molinillo::DependencyGraph::Action
  def down(graph); end
  def initialize(name); end
  def name; end
  def self.action_name; end
  def up(graph); end
end
class Bundler::Molinillo::DependencyGraph::SetPayload < Bundler::Molinillo::DependencyGraph::Action
  def down(graph); end
  def initialize(name, payload); end
  def name; end
  def payload; end
  def self.action_name; end
  def up(graph); end
end
class Bundler::Molinillo::DependencyGraph::Tag < Bundler::Molinillo::DependencyGraph::Action
  def down(_graph); end
  def initialize(tag); end
  def self.action_name; end
  def tag; end
  def up(_graph); end
end
class Bundler::Molinillo::DependencyGraph::Log
  def add_edge_no_circular(graph, origin, destination, requirement); end
  def add_vertex(graph, name, payload, root); end
  def delete_edge(graph, origin_name, destination_name, requirement); end
  def detach_vertex_named(graph, name); end
  def each; end
  def initialize; end
  def pop!(graph); end
  def push_action(graph, action); end
  def reverse_each; end
  def rewind_to(graph, tag); end
  def set_payload(graph, name, payload); end
  def tag(graph, tag); end
  extend Enumerable
end
class Bundler::Molinillo::DependencyGraph::Vertex
  def ==(other); end
  def _path_to?(other, visited = nil); end
  def _recursive_predecessors(vertices = nil); end
  def _recursive_successors(vertices = nil); end
  def ancestor?(other); end
  def descendent?(other); end
  def eql?(other); end
  def explicit_requirements; end
  def hash; end
  def incoming_edges; end
  def incoming_edges=(arg0); end
  def initialize(name, payload); end
  def inspect; end
  def is_reachable_from?(other); end
  def name; end
  def name=(arg0); end
  def outgoing_edges; end
  def outgoing_edges=(arg0); end
  def path_to?(other); end
  def payload; end
  def payload=(arg0); end
  def predecessors; end
  def recursive_predecessors; end
  def recursive_successors; end
  def requirements; end
  def root; end
  def root=(arg0); end
  def root?; end
  def shallow_eql?(other); end
  def successors; end
end
class Bundler::Molinillo::DependencyGraph::Edge < Struct
  def destination; end
  def destination=(_); end
  def origin; end
  def origin=(_); end
  def requirement; end
  def requirement=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
end
class Bundler::Molinillo::ResolutionState < Struct
  def activated; end
  def activated=(_); end
  def conflicts; end
  def conflicts=(_); end
  def depth; end
  def depth=(_); end
  def name; end
  def name=(_); end
  def possibilities; end
  def possibilities=(_); end
  def requirement; end
  def requirement=(_); end
  def requirements; end
  def requirements=(_); end
  def self.[](*arg0); end
  def self.empty; end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
  def unused_unwind_options; end
  def unused_unwind_options=(_); end
end
class Bundler::Molinillo::DependencyState < Bundler::Molinillo::ResolutionState
  def pop_possibility_state; end
end
class Bundler::Molinillo::PossibilityState < Bundler::Molinillo::ResolutionState
end
module Bundler::Molinillo::SpecificationProvider
  def allow_missing?(dependency); end
  def dependencies_for(specification); end
  def name_for(dependency); end
  def name_for_explicit_dependency_source; end
  def name_for_locking_dependency_source; end
  def requirement_satisfied_by?(requirement, activated, spec); end
  def search_for(dependency); end
  def sort_dependencies(dependencies, activated, conflicts); end
end
module Bundler::Molinillo::Delegates::ResolutionState
  def activated; end
  def conflicts; end
  def depth; end
  def name; end
  def possibilities; end
  def requirement; end
  def requirements; end
  def unused_unwind_options; end
end
class Bundler::Molinillo::Resolver
  def initialize(specification_provider, resolver_ui); end
  def resolve(requested, base = nil); end
  def resolver_ui; end
  def specification_provider; end
end
class Bundler::Molinillo::Resolver::Resolution
  def activate_new_spec; end
  def attempt_to_activate; end
  def attempt_to_filter_existing_spec(vertex); end
  def base; end
  def binding_requirement_in_set?(requirement, possible_binding_requirements, possibilities); end
  def binding_requirements_for_conflict(conflict); end
  def build_details_for_unwind; end
  def conflict_fixing_possibilities?(state, binding_requirements); end
  def create_conflict(underlying_error = nil); end
  def debug(depth = nil, &block); end
  def end_resolution; end
  def filter_possibilities_after_unwind(unwind_details); end
  def filter_possibilities_for_parent_unwind(unwind_details); end
  def filter_possibilities_for_primary_unwind(unwind_details); end
  def filtered_possibility_set(vertex); end
  def find_state_for(requirement); end
  def group_possibilities(possibilities); end
  def handle_missing_or_push_dependency_state(state); end
  def indicate_progress; end
  def initial_state; end
  def initialize(specification_provider, resolver_ui, requested, base); end
  def iteration_rate; end
  def iteration_rate=(arg0); end
  def locked_requirement_named(requirement_name); end
  def locked_requirement_possibility_set(requirement, activated = nil); end
  def original_requested; end
  def parent_of(requirement); end
  def possibilities_for_requirement(requirement, activated = nil); end
  def possibility; end
  def possibility_satisfies_requirements?(possibility, requirements); end
  def process_topmost_state; end
  def push_state_for_requirements(new_requirements, requires_sort = nil, new_activated = nil); end
  def raise_error_unless_state(conflicts); end
  def require_nested_dependencies_for(possibility_set); end
  def requirement_for_existing_name(name); end
  def requirement_tree_for(requirement); end
  def requirement_trees; end
  def resolve; end
  def resolve_activated_specs; end
  def resolver_ui; end
  def specification_provider; end
  def start_resolution; end
  def started_at; end
  def started_at=(arg0); end
  def state; end
  def states; end
  def states=(arg0); end
  def unwind_for_conflict; end
  def unwind_options_for_requirements(binding_requirements); end
  include Bundler::Molinillo::Delegates::ResolutionState
  include Bundler::Molinillo::Delegates::SpecificationProvider
end
class Bundler::Molinillo::Resolver::Resolution::Conflict < Struct
  def activated_by_name; end
  def activated_by_name=(_); end
  def existing; end
  def existing=(_); end
  def locked_requirement; end
  def locked_requirement=(_); end
  def possibility; end
  def possibility_set; end
  def possibility_set=(_); end
  def requirement; end
  def requirement=(_); end
  def requirement_trees; end
  def requirement_trees=(_); end
  def requirements; end
  def requirements=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
  def underlying_error; end
  def underlying_error=(_); end
end
class Bundler::Molinillo::Resolver::Resolution::PossibilitySet < Struct
  def dependencies; end
  def dependencies=(_); end
  def latest_version; end
  def possibilities; end
  def possibilities=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
  def to_s; end
end
class Bundler::Molinillo::Resolver::Resolution::UnwindDetails < Struct
  def <=>(other); end
  def all_requirements; end
  def conflicting_requirements; end
  def conflicting_requirements=(_); end
  def requirement_tree; end
  def requirement_tree=(_); end
  def requirement_trees; end
  def requirement_trees=(_); end
  def requirements_unwound_to_instead; end
  def requirements_unwound_to_instead=(_); end
  def reversed_requirement_tree_index; end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
  def state_index; end
  def state_index=(_); end
  def state_requirement; end
  def state_requirement=(_); end
  def sub_dependencies_to_avoid; end
  def unwinding_to_primary_requirement?; end
  include Comparable
end
module Bundler::Molinillo::UI
  def after_resolution; end
  def before_resolution; end
  def debug(depth = nil); end
  def debug?; end
  def indicate_progress; end
  def output; end
  def progress_rate; end
end
class Bundler::Resolver
  def after_resolution; end
  def amount_constrained(dependency); end
  def before_resolution; end
  def debug(depth = nil); end
  def debug?; end
  def dependencies_for(specification); end
  def formatted_versions_with_platforms(versions_with_platforms); end
  def index_for(dependency); end
  def indicate_progress; end
  def initialize(index, source_requirements, base, gem_version_promoter, additional_base_requirements, platforms); end
  def name_for(dependency); end
  def name_for_explicit_dependency_source; end
  def name_for_locking_dependency_source; end
  def relevant_sources_for_vertex(vertex); end
  def requirement_satisfied_by?(requirement, activated, spec); end
  def search_for(dependency); end
  def self.platform_sort_key(platform); end
  def self.resolve(requirements, index, source_requirements = nil, base = nil, gem_version_promoter = nil, additional_base_requirements = nil, platforms = nil); end
  def self.sort_platforms(platforms); end
  def sort_dependencies(dependencies, activated, conflicts); end
  def start(requirements); end
  def validate_resolved_specs!(resolved_specs); end
  def verify_gemfile_dependencies_are_found!(requirements); end
  def version_conflict_message(e); end
  include Bundler::Molinillo::SpecificationProvider
  include Bundler::Molinillo::UI
end
class Bundler::Resolver::SpecGroup
  def ==(other); end
  def __dependencies; end
  def activate_platform!(platform); end
  def dependencies_for_activated_platforms; end
  def eql?(other); end
  def for?(platform); end
  def hash; end
  def ignores_bundler_dependencies; end
  def ignores_bundler_dependencies=(arg0); end
  def initialize(all_specs); end
  def metadata_dependencies(spec, platform); end
  def name; end
  def name=(arg0); end
  def source; end
  def source=(arg0); end
  def to_s; end
  def to_specs; end
  def version; end
  def version=(arg0); end
  include Bundler::GemHelpers
end
class Bundler::Runtime
  def cache(custom_path = nil); end
  def check_for_activated_spec!(spec); end
  def clean(dry_run = nil); end
  def current_dependencies; end
  def dependencies; end
  def gems; end
  def initialize(root, definition); end
  def lock(opts = nil); end
  def prune_cache(cache_path); end
  def prune_gem_cache(resolve, cache_path); end
  def prune_git_and_path_cache(resolve, cache_path); end
  def remove_dir(dir, dry_run); end
  def requested_specs; end
  def require(*groups); end
  def requires; end
  def self.definition_method(meth); end
  def setup(*groups); end
  def setup_manpath; end
  def specs; end
  include Bundler::SharedHelpers
end
class Bundler::DepProxy
  def ==(other); end
  def __platform; end
  def dep; end
  def eql?(other); end
  def hash; end
  def initialize(dep, platform); end
  def method_missing(*args, &blk); end
  def name; end
  def requirement; end
  def to_s; end
  def type; end
end
class Bundler::StubSpecification < Bundler::RemoteSpecification
  def _remote_specification; end
  def activated; end
  def activated=(activated); end
  def default_gem; end
  def full_gem_path; end
  def full_require_paths; end
  def ignored; end
  def ignored=(arg0); end
  def load_paths; end
  def loaded_from; end
  def matches_for_glob(glob); end
  def missing_extensions?; end
  def raw_require_paths; end
  def self.from_stub(stub); end
  def source=(source); end
  def stub; end
  def stub=(arg0); end
  def to_yaml; end
end
class Bundler::EndpointSpecification < Gem::Specification
  def __swap__(spec); end
  def _local_specification; end
  def bindir; end
  def build_dependency(name, requirements); end
  def checksum; end
  def dependencies; end
  def dependencies=(arg0); end
  def executables; end
  def extensions; end
  def fetch_platform; end
  def initialize(name, version, platform, dependencies, metadata = nil); end
  def load_paths; end
  def local_specification_path; end
  def name; end
  def parse_metadata(data); end
  def platform; end
  def post_install_message; end
  def remote; end
  def remote=(arg0); end
  def require_paths; end
  def required_ruby_version; end
  def required_rubygems_version; end
  def source; end
  def source=(arg0); end
  def version; end
  include Bundler::MatchPlatform
end
class Bundler::RubyVersion
  def ==(other); end
  def diff(other); end
  def engine; end
  def engine_gem_version; end
  def engine_versions; end
  def exact?; end
  def gem_version; end
  def host; end
  def initialize(versions, patchlevel, engine, engine_version); end
  def matches?(requirements, version); end
  def patchlevel; end
  def self.from_string(string); end
  def self.system; end
  def single_version_string; end
  def to_gem_version_with_patchlevel; end
  def to_s(versions = nil); end
  def versions; end
  def versions_string(versions); end
end
module Gem::Ext
end
module Kernel
  def self.gem(dep, *reqs); end
end
